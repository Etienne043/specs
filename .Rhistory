A_labels[i,] <- n:(2*n-1) - i + 1                     #Fill diagonals row-wise
}
AB_labels <- rbind(t(A_labels),matrix(1:(n^2)+2*n-1,n,n))   #Add individual labels for B (groups of size one)
AB_index <- c(AB_labels)[-ind_x_rem]                        #Get rid off coefficients for the diagonal of A
lambda_max <- lambdamax(cbind(1,x_g),y_g,c(NA,AB_index),model=LinReg(),center = T,standardize = T) #Max lambda
lambdas <- exp(seq(log(lambda_max),1e-5*log(lambda_max),length.out = 50))                          #Lambda sequence
test <- grplasso(cbind(1,x_g),y_g,c(NA,AB_index),model=LinReg(),lambda = lambdas,center=T,standardize=T) #Group Lasso
coefs <- coef(test) #Extract coefficients
MSE <- (matrix(rep(y_g,ncol(coefs)),ncol=ncol(coefs))-cbind(1,x_g)%*%coefs)^2
dfs <- apply(coefs,2,function(x){sum(x!=0)})*log(length(y_g))/length(y_g)
BICs <- log(colMeans(MSE))+dfs; names(BICs) <- 1:length(BICs)
coef_vec <- rep(0,2*n^2)                                  #Initialize empty vector for vectorized matrix
coef_vec[-ind_x_rem] <- coefs[-1,which.min(BICs)]         #Fill all elements with the best coefficients (no diagonal coefs)
AB_glas <- matrix(coef_vec,ncol=n)                        #Initialize estimated (A,B)'
A_glas <- t(AB_glas[1:n,1:n])                             #Obtain estimated A
B_glas <- t(AB_glas[(n+1):(2*n),1:n])                     #Obtain estimated B
pred_glas <- solve(diag(n)-A_glas,B_glas)%*%Z[,n]
}
#collect output
if(glasso){
coef_errors <- c(norm(A_las-A, type = "F"),norm(B_las-B, type = "F"),
norm(A_glas-A, type = "F"),norm(B_glas-B, type = "F"),
norm(A_YW-A, type = "F"),norm(B_YW-B, type = "F"))
pred_errors <- c(norm(pred_las-newZ, type = "F"),norm(pred_glas-newZ, type = "F"),
norm(pred_YW-newZ, type = "F"))
}else{
coef_errors <- c(norm(A_las-A, type = "F"),norm(B_las-B, type = "F"),
NA,NA,
norm(A_YW-A, type = "F"),norm(B_YW-B, type = "F"))
pred_errors <- c(norm(pred_las-newZ, type = "F"),NA,
norm(pred_YW-newZ, type = "F"))
}
list(coef_errors=coef_errors,pred_errors=pred_errors)
}
#Prepare clusters and RNG
set.seed(110)
cl <- makeCluster(detectCores()-1)
clusterSetRNGStream(cl,iseed=123457)
varlist <- ls()
clusterExport(cl=cl,c(varlist,"glmnet","grplasso","LinReg","lambdamax","specs_tr_opt","specs_tr"))
#Perform parallel computations
result_raw <- pblapply(1:Nsim,one_sim,glasso=T,cl=cl)
stopCluster(cl)
#Organize and save results
coef_errorlist <- do.call(rbind,lapply(result_raw,function(x){x$coef_errors}))
pred_errorlist <- do.call(rbind,lapply(result_raw,function(x){x$pred_errors}))
colnames(coef_errorlist) <- c("A_las","B_las","A_glas","B_glas","A_YW","B_YW")
colnames(pred_errorlist) <- c("lasso","group_lasso","Gao_YW")
#workfile <- paste("Results for t=",t," m=",m," Nsim=",Nsim,".Rdata",sep="") #file name
#save(coef_errorlist,pred_errorlist,file=workfile)                           #Save results
#Display output
colMeans(coef_errorlist, na.rm = FALSE, dims = 1)
colMeans(pred_errorlist, na.rm = FALSE, dims = 1)
library(specs)
?spec
?specs_opt
epsilon <- matrix(rnorm(1000),100,10)
x <- apply(epsilon,2,cumsum)
dim(x)
library(specs)
library(specs)
library(specs)
?specs
x <- matrix(rnorm(1000),100,10)
beta <- c(rep(1,5),rep(0,5))
y <- x%*%beta + rnorm(100)
my_specs <- specs(y,x,p=2)
my_specs$gammas[,950]
my_specs$gammas[,990]
my_specs$gammas[,985]
my_specs <- specs(y,x,p=1)
my_specs2 <- specs(y,x,ADL=TRUE,p=1)
my_specs$gammas[,990]
beta <- c(1,rep(-1,4),rep(0,5))
y <- x%*%beta + rnorm(100)
my_specs <- specs(y,x,p=1)
my_specs[,990]
my_specs$gammas[,990]
?specs_tr
library(specs)
?specs_tr
function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL)
epsilon <- matrix(rnorm(1000),100,10)
x <- apply(epsilon,2,cumsum)
beta <- c(1,rep(-1,4),rep(0,5))
y <- x%*%beta + rnorm(100)
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr(y_d,z_l,w,deterministics="constant")
my_specs$gammas[,990]
library(specs)
y <- Unempl_GT[,1]
x <- Unempl_GT[,sample(c(2:ncol(Unempl_GT)),10)]
dim(x)
dim(y)
length(y)
ncol(Unempl_GT)
colnames(Unempl_GT)
?sample
?specs_tr_opt
library(specs)
?specs_tr_opt
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr_opt(y,z_l,w,type="AIC",weights="ols",deterministics="constant")
?specs_tr_opt
my_specs <- specs_tr_opt(y,z_l,w,rule="AIC",weights="ols",deterministics="constant")
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w cor
dim(w)
length(y_d)
my_specs <- specs_tr_opt(y,z_l,w,rule="AIC",weights="ols",deterministics="constant")
?specs_tr_opt
library(specs)
?specs_tr_opt
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr_opt(y,z_l,w)
class(z_l)
class(Unempl_GT)
str(Unempl_GT)
class(y)
x <- as.matrix(Unempl_GT[,index_GT])
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
class(z_l)
load("E:/Dropbox/Research/specs/data/Unempl_GT.RData")
#Organize data
z <- as.matrix(Unempl_GT[,1])
y <- z[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- z[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
class(z)
#Organize data
z <- matrix(Unempl_GT[,1])
class(z)
z
#Organize data
z <- matrix(Unempl_GT)
class(z)
z
head(z)
#Organize data
z <- as.matrix(Unempl_GT)
head(z)
z <- Unempl_GT
y <- z[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- z[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr_opt(y,z_l,w)
eps <- matrix(rnorm(100*5),100,5)
x <- cumsum(eps)
dim(x)
x <- apply(eps,2,cumsum)
eps <- matrix(rnorm(100*5),100,5)
x <- apply(eps,2,cumsum)
beta <- c(-1,1,1,rep(0,3))
y <- x%*%beta + rnorm(100)
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
function (n, mean = 0, sd = 1)
.Call(C_rnorm, n, mean, sd)
eps <- matrix(rnorm(100*5),100,5)
x <- apply(eps,2,cumsum)
dim(x)
x <- apply(eps,2,cumsum)
beta <- c(-1,1,rep(0,3))
y <- x%*%beta + rnorm(100)
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr_opt(y,z_l,w)
my_specs <- specs_tr_opt(y_d,z_l,w)
class(z_l)
eps <- matrix(rnorm(100*5),100,5)
x <- apply(eps,2,cumsum)
beta <- c(-1,1,rep(0,3))
y <- x%*%beta + rnorm(100)
y_d <- y[-1]-y[-100]
class(x)
class(eps)
class(y)
#Organize data
z <- as.matrix(Unempl_GT)
class(z)
class(1:10)
class(rnorm(1:10))
class(rnorm(10))
class(matrix(rnorm(1:100),10,10))
ncol(1:10)
is.null(1:10)
x <- matrix(rnorm(1:10),5,2)
class(x)
is.numeric(rnorm(10))
is.matrix(Unempl_GT)
library(specs)
?specs_tr_opt
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a ce
my_specs <- specs_tr_opt(y_d,z_l,w,rule="AIC",weights="ols",deterministics="constant")
my_specs$gamma_opt
?specs
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
#Estimate a CECM with 1 lagged differences
my_specs <- specs(y,x,p=1)
#Estimate a CECM with 1 lagged differences and no group penalty
my_specs2 <- specs(y,x,p=1,lambda_g=0)
#Estimate an autoregressive distributed lag model with 2 lagged differences
my_specs3 <- specs(y,x,ADL=TRUE,p=2)
?specs_opt
#Estimate an automatically optimized model for unemployment and ten google trends
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
#Estimate a CECM with 1 lagged difference and penalty chosen by the minimum BIC
my_specs <- specs_opt(y,x,p=1,rule="BIC")
coefs <- my_specs$gamma_opt
#Estimate an automatically optimized model for unemployment and ten google trends
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
#Estimate a CECM with 1 lagged difference and penalty chosen by the minimum BIC
my_specs <- specs_opt(y,x,p=1,rule="BIC")
coefs <- my_specs$gamma_opt
#Estimate an automatically optimized model for unemployment and ten google trends
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
#Estimate a CECM with 1 lagged difference and penalty chosen by the minimum BIC
my_specs <- specs_opt(y,x,p=1,rule="BIC")
coefs <- my_specs$gamma_opt
?specs_tr
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr(y_d,z_l,w,deterministics="constant")
my_specs <- specs_tr(y_d,NULL,w,deterministics="constants")
library(specs)
?specs_tr
?specs_tr
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr(y_d,z_l,w,deterministics="constant")
#Estimate an ADL model on pre-transformed data with a constant
my_specs <- specs_tr(y_d,NULL,w,ADL=TRUE,deterministics="constants")
library(specs)
?specs_tr
#Organize data
y <- Unempl_GT[,1]
index_GT <- sample(c(2:ncol(Unempl_GT)),10)
x <- Unempl_GT[,index_GT]
y_d <- y[-1]-y[-100]
z_l <- cbind(y[-100],x[-100,])
w <- x[-1,]-x[-100,] #This w corresponds to a cecm with p=0 lagged differences
my_specs <- specs_tr(y_d,z_l,w,deterministics="constant")
#Estimate an ADL model on pre-transformed data with a constant
my_specs <- specs_tr(y_d,NULL,w,ADL=TRUE,deterministics="constant")
library(specs)
library(specs)
library(specs)
library(specs)
library(specs)
library(specs)
tools::package_native_routine_registration_skeleton(".")
tools::package_native_routine_registration_skeleton(".")
library(specs)
library(specs)
library(specs)
?specs_tr_opt
library(specs)
tools::package_native_routine_registration_skeleton(".")
tools::package_native_routine_registration_skeleton(".")
install.packages("devtools")
library(devtools)
tools::package_native_routine_registration_skeleton(".")
library(specs)
tools::package_native_routine_registration_skeleton("specs")
tools::package_native_routine_registration_skeleton("stpp")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
library(devtools)
has_devel()
library(specs)
tools::package_native_routine_registration_skeleton()
tools::package_native_routine_registration_skeleton(".")
library(devtools)
tools::package_native_routine_registration_skeleton(".", character_only = FALSE)
file.exists("~/.ssh/id_rsa.pub")
file.exists("~/.ssh/id_rsa.pub")
get_wd()
getwd()
setwd("C:/Users/Etienne")
file.exists("~/.ssh/id_rsa.pub")
file.exists("C:/Users/Etienne/.ssh/id_rsa.pub")
install.packages("learnr")
library(rmarkdown)
library(specs)
dim(Unempl_GT)
Unempl_GT[,1]
?specs
library(specs)
library(specs)
library(specs)
?specs
unemployment <- Unempl_GT[,1]
GT <- Unempl_GT[,-1]
my_specs <- specs(unemployment,GT,p=1)
unemployment <- Unempl_GT[,1]
GT <- Unempl_GT[,2:11]
my_specs <- specs(unemployment,GT,p=1)
#library(specs)
unemployment <- Unempl_GT[,1] #Extract the Dutch unemployment levels (x1,000)
GT <- Unempl_GT[,2:11] #Select the first ten Google Trends
my_specs <- specs(unemployment,GT,p=1) #Estimate specs
my_coefs <- my_specs$gammas #store the coefficients
#library(specs)
my_specs2 <- specs(unemployment,GT,p=0) #Estimate specs without any lagged differences
my_coefs2 <- my_specs$gammas #store the new coefficients
#library(specs)
my_specs3 <- specs(unemployment,GT,deterministics = "both") #Estimate specs with a constant and trend included
my_coefs3 <- my_specs$gammas #Store the new coefficients
my_deterministics <- my_specs$thetas #Store the coefficients of the deterministic component
#library(specs)
my_adl <- specs(unemployment,GT,ADL=TRUE)
my_coefs <- my_specs$gammas
?specs_opt
rm(list = ls())
library(specs)
#library(specs)
unemployment <- Unempl_GT[,1] #Extract the Dutch unemployment levels (x1,000)
GT <- Unempl_GT[,2:11] #Select the first ten Google Trends
my_specs <- specs(unemployment,GT,p=1) #Estimate specs
my_coefs <- my_specs$gammas #store the coefficients
#library(specs)
my_specs <- specs(unemployment,GT,p=0) #Estimate specs without any lagged differences
#library(specs)
my_specs <- specs(unemployment,GT,deterministics = "both") #Estimate specs with a constant and trend included
my_coefs <- my_specs$gammas #Store the new coefficients
my_deterministics <- my_specs$thetas #Store the coefficients of the deterministic component
#library(specs)
my_adl <- specs(unemployment,GT,ADL=TRUE) #Estimate and ADL model
my_coefs <- my_specs$gammas #Store the coefficients (smaller matrix than before)
#library(specs)
z <- cbind(unemployment,GT)
y_d <- diff(unemployment) #Difference the dependent variable
z_l <- GT[-nrow(GT),] #Lagged levels of the data
w <- diff(GT) #Contemporaneous differences (corresponding to p=0)
my_specs <- specs_tr(y_d,z_l,w) #Estimate a CECM on pre-transformed data
my_adl <- specs_tr(y_d,NULL,w,ADL=TRUE) #Estimate an ADL model on pre-transformed data
my_specs <- specs(unemployment,GT,lambda_g=0) #Estimate a CECM without group penalty
my_specs <- specs_opt(unemployment,GT,rule="BIC") #Estimate a CECM with the optimal penalty chosen by BIC
coef_opt <- my_specs$gamma_opt #Extract the optimal coefficients
coefs_opt <- my_specs$gamma_opt #Extract the optimal coefficients
coefs_opt
my_adl <- specs_opt(unemployment,GT,rule="AIC",ADL=TRUE) #Estimate an ADL model with the optimal penalty chosen by BIC
my_specs <- specs_opt(unemployment,GT,rule="TSCV",CV_cutoff=4/5) #Estimate a CECM with the optimal penalty chosen by TSCV
my_specs <- specs_opt(y_d,z_l,w,rule="BIC") #Estimate a CECM based on pre-transformed data, penalty chosen by BIC
my_specs <- specs_tr_opt(y_d,z_l,w,rule="BIC") #Estimate a CECM based on pre-transformed data, penalty chosen by BIC
my_specs <- specs(unemployment,GT,weights="ols",k_delta=2,k_pi=1) #Estimate specs with OLS and variable weight exponents
?bibentry
library(devtools)
install_github(bootUR)
install_github(bootstrapUR)
install_github(specs)
install_github("bootUR")
install_github("specs")
install_github("smeekes/bootUR")
setwd("E:/Dropbox/Research/SPECS R")
GDP
GDP_NL
GDP_nl
GDP_NL
?bootUR
??bootUR
rm(list=ls())
setwd("E:/Dropbox/Research/SPECS R")
set.seed(1234)
#DGP function
VECM <- function(alpha,beta,t){
#Obtain dimensions
n <- nrow(alpha)
#Generate covariance matrix
m.ind <- matrix(rep(seq(1,n),n),n,n)
S <- exp(log(0.6)*abs(m.ind-t(m.ind))) #correlation matrix
#Generate errors and starting values
C <- t(chol(S))
e <- matrix(rnorm(n*t),n,t)
eps <- C%*%e
#obtain VAR coefficients
Pi <- alpha%*%t(beta)
P <- (Pi+diag(n))
phi <- 0.4*diag(n)
P <- cbind(P+phi,-phi)
#Check roots
ps <- ncol(P)
p.comp <- rbind(P,cbind(diag(n),matrix(0,n,n)))
roots <- abs(eigen(p.comp)$values)
max.root <- max(roots)
if(max(roots)> (1+1e-6)){
stop(paste("The largest absolute root is ",max(roots),sep=""))
}
#Generate VECM
z <- matrix(0,n,2)
for(i in 1:t){
z.new <- P%*%as.vector(z[,(1+i):i]) + eps[,i]
z <- cbind(z,z.new)
}
z <- t(z[,-c(1:2)])
#Obtain parameters for the conditional model
pi0 <- as.numeric(t(S[1,-1])%*%solve(S[-1,-1]))
pi0[abs(pi0)<1e-15] <- 0 #numerical inaccuracies
delta <- as.numeric(t(c(1,-pi0))%*%Pi)
pi1 <- as.numeric(t(c(1,-pi0))%*%phi)
pi1[abs(pi1)<1e-15] <- 0 #numerical inaccuracies
#Output
list(alpha=alpha,beta=beta,delta=delta,pi0=pi0,pi1=pi1,z=z)
} #Create simple VECM(1)
#Get data
r <- 3; t <- 1000
beta <- rbind(kronecker(diag(1,r),c(1,rep(-1,4)))[,1:r])
beta <- matrix(c(1,rep(-1,4),rep(0,10)),ncol=1)
alpha <- -0.5*beta
data <- VECM(alpha,beta,t)
z <- data$z; delta <- data$delta
boot_union(z[,1])
panel_out <- paneltest(z[,1], boot = "DWB", B = 399, verbose = TRUE)
library("bootUR")
?bootUR
?boot_df
y <- z[,12]
test1 <- boot_df(y)
test1
iADF_out <- iADFtest(z[, 1:5], boot = "MBB", B = 399, verbose = TRUE, union = FALSE,
dc = 2, detr = "OLS")
library(specs)
library(specs)
package_native_routine_registration_skeleton(".", character_only = FALSE)
tools::package_native_routine_registration_skeleton(".", character_only = FALSE)
tools::package_native_routine_registration_skeleton(".", character_only = FALSE)
library(specs)
library(specs)
library(specs)
library(specs)
install.packackages("devtools")
install.packages("devtools")
install_github("wijler/specs")
library(devtools)
library("devtools")
install_github("wijler/specs")
?specs
1/sqrt(20)
5*.9/sqrt(2)
5*.9/sqrt(20)
5*1.4/sqrt(20)
5*1.9/sqrt(20)
5*1.8/sqrt(20)
library(devtools)
devtools::build()
library(specs)
library(specs)
library(specs)
devtools::build()
library(devtools)
library(specs)
library(specs)
library(specs)
library(specs)
library(specs)
library(specs)
install_github("wijler/specs")
